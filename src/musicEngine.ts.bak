import { Pcs12 } from './pcs12';
import pcsGraphData from './pcsGraphData.json';

// Tone.js types - we'll import the actual module dynamically
type ToneType = typeof import('tone');
let Tone: ToneType | null = null;

// Default constants
const DEFAULT_BPM = 45;
const DEFAULT_MEAN_NOTES_PER_BAR = 6;
const MAX_VOICES = 16;
const OCTAVE_MIN = 5;
const OCTAVE_MAX = 8;
const BARS_PER_CHANGE = 4;

// User-configurable parameters with defaults
export interface EnvelopeParams {
  attack: number;
  decay: number;
  sustain: number;
  release: number;
}

export interface VibratoParams {
  rate: number;
  depth: number;
}

export interface TremoloParams {
  rate: number;
  depth: number;
}

export interface SynthParams {
  envelope: EnvelopeParams;
  vibrato: VibratoParams;
  tremolo: TremoloParams;
  maxNoteDuration: number;
}

export const DEFAULT_SYNTH_PARAMS: SynthParams = {
  envelope: {
    attack: 0.01,
    decay: 0.1,
    sustain: 0.8,
    release: 1.8
  },
  vibrato: {
    rate: 4.8,
    depth: 0.003
  },
  tremolo: {
    rate: 2.1,
    depth: 0.25
  },
  maxNoteDuration: 2.4
};

function midiToFreq(midi: number): number {
  return 440 * Math.pow(2, (midi - 69) / 12);
}

// Use 'any' for Tone.js types since we're loading dynamically
interface Voice {
  synth: any | null;
  vibrato: any | null;
  tremolo: any | null;
  startTime: number;
  frequency: number;
}

/**
 * PCS Relation Graph for navigating between pitch class sets.
 * Uses precomputed graph data for instant initialization.
 */
class PcsRelationGraph {
  private nodes: Pcs12[];
  private adjacency: number[][];
  private currentIndex: number;

  constructor() {
    // Load precomputed data
    this.nodes = pcsGraphData.nodes.map(str => Pcs12.fromBinaryString(str));
    this.adjacency = pcsGraphData.adjacency;
    this.currentIndex = Math.floor(Math.random() * this.nodes.length);
  }

  current(): Pcs12 {
    return this.nodes[this.currentIndex];
  }

  advance(): void {
    if (this.nodes.length === 0) return;

    const neighbors = this.adjacency[this.currentIndex];
    if (neighbors.length > 0) {
      this.currentIndex = neighbors[Math.floor(Math.random() * neighbors.length)];
      return;
    }
    
    this.currentIndex = Math.floor(Math.random() * this.nodes.length);
  }
}

/**
 * Main music engine using Tone.js.
 */
export class MusicEngine {
  private isPlaying: boolean = false;
  private pcsGraph: PcsRelationGraph;
  private activePitchClasses: number[] = [];
  private voices: Voice[] = [];
  private nextNoteTime: number = 0;
  private nextGraphHopTime: number = 0;
  private schedulerId: number | null = null;
  private reverb: any | null = null;
  private masterGain: any | null = null;
  private synthParams: SynthParams = { ...DEFAULT_SYNTH_PARAMS };
  
  // Timing parameters
  private bpm: number = DEFAULT_BPM;
  private meanNotesPerBar: number = DEFAULT_MEAN_NOTES_PER_BAR;
  
  // Callbacks
  onChordChange?: (chord: string) => void;
  onNoteTriggered?: (pitchClass: number) => void;
  onPlayStateChange?: (isPlaying: boolean) => void;

  constructor() {
    this.pcsGraph = new PcsRelationGraph();
    this.voices = [];
    this.setupMediaSession();
  }

  // Computed timing values
  private get sixteenthSeconds(): number {
    return (60 / this.bpm) / 4;
  }

  private get barSeconds(): number {
    return 4 * (60 / this.bpm);
  }

  private get lambda(): number {
    return this.meanNotesPerBar / this.barSeconds;
  }

  private setupMediaSession(): void {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: 'NCG777 Music Box',
        artist: 'Generative Ambient',
        album: 'Pitch Class Sets',
        artwork: [
          { src: '/pwa-192x192.svg', sizes: '192x192', type: 'image/svg+xml' },
          { src: '/pwa-512x512.svg', sizes: '512x512', type: 'image/svg+xml' }
        ]
      });

      navigator.mediaSession.setActionHandler('play', () => {
        this.start();
      });

      navigator.mediaSession.setActionHandler('pause', () => {
        this.stop();
      });

      navigator.mediaSession.setActionHandler('stop', () => {
        this.stop();
      });
    }
  }

  private updateMediaSessionState(): void {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.playbackState = this.isPlaying ? 'playing' : 'paused';
    }
  }

  setLambda(meanNotesPerBar: number): void {
    this.meanNotesPerBar = meanNotesPerBar;
  }

  setBpm(bpm: number): void {
    this.bpm = Math.max(20, Math.min(300, bpm)); // Clamp to reasonable range
  }

  getBpm(): number {
    return this.bpm;
  }

  setSynthParams(params: Partial<SynthParams>): void {
    if (params.envelope) {
      this.synthParams.envelope = { ...this.synthParams.envelope, ...params.envelope };
    }
    if (params.vibrato) {
      this.synthParams.vibrato = { ...this.synthParams.vibrato, ...params.vibrato };
    }
    if (params.tremolo) {
      this.synthParams.tremolo = { ...this.synthParams.tremolo, ...params.tremolo };
    }
    if (params.maxNoteDuration !== undefined) {
      this.synthParams.maxNoteDuration = params.maxNoteDuration;
    }
  }

  getSynthParams(): SynthParams {
    return { ...this.synthParams };
  }

  private generateExponentialDelay(): number {
    // Exponential distribution with rate lambda
    return -Math.log(1 - Math.random()) / this.lambda;
  }

  private quantizeToSixteenth(time: number): number {
    return Math.ceil(time / this.sixteenthSeconds) * this.sixteenthSeconds;
  }

  private refreshPitchClasses(): void {
    this.activePitchClasses = this.pcsGraph.current().asSequence();
    if (this.onChordChange) {
      this.onChordChange(this.pcsGraph.current().toString());
    }
  }

  private createSynth(): { synth: any; vibrato: any; tremolo: any } {
    if (!Tone) throw new Error('Tone.js not loaded');
    
    // Create synth and connect directly to destination
    // Using toDestination() avoids connect() issues with dynamic imports
    const synth = new Tone.Synth({
      oscillator: {
        type: 'sine'
      },
      envelope: {
        attack: this.synthParams.envelope.attack,
        decay: this.synthParams.envelope.decay,
        sustain: this.synthParams.envelope.sustain,
        release: this.synthParams.envelope.release
      },
      volume: -12 // Reduce volume to prevent clipping with multiple voices
    }).toDestination();

    return { synth, vibrato: null, tremolo: null };
  }

  private safeDispose(node: any): void {
    if (!node) return;
    try {
      if (typeof node.triggerRelease === 'function') {
        node.triggerRelease();
      }
      node.dispose();
    } catch (e) {
      // Ignore disposal errors - node may already be disposed or in invalid state
    }
  }

  private acquireVoice(): Voice {
    // Find inactive voice
    const inactive = this.voices.find(v => v.synth === null);
    if (inactive) {
      return inactive;
    }

    // Find oldest voice
    if (this.voices.length >= MAX_VOICES) {
      const oldest = this.voices.reduce((prev, curr) => 
        prev.startTime < curr.startTime ? prev : curr
      );
      this.safeDispose(oldest.synth);
      oldest.synth = null;
      this.safeDispose(oldest.vibrato);
      oldest.vibrato = null;
      this.safeDispose(oldest.tremolo);
      oldest.tremolo = null;
      return oldest;
    }

    // Create new voice slot
    const newVoice: Voice = { synth: null, vibrato: null, tremolo: null, startTime: 0, frequency: 0 };
    this.voices.push(newVoice);
    return newVoice;
  }

  private triggerNote(frequency: number, when: number): void {
    const voice = this.acquireVoice();
    
    this.safeDispose(voice.synth);
    voice.synth = null;
    this.safeDispose(voice.vibrato);
    voice.vibrato = null;
    this.safeDispose(voice.tremolo);
    voice.tremolo = null;

    const { synth, vibrato, tremolo } = this.createSynth();
    voice.synth = synth;
    voice.vibrato = vibrato;
    voice.tremolo = tremolo;
    voice.startTime = when;
    voice.frequency = frequency;

    // Schedule note with auto-release after maxNoteDuration
    voice.synth.triggerAttack(frequency, when);
    voice.synth.triggerRelease(when + this.synthParams.maxNoteDuration * 0.8);
  }

  private triggerRandomNote(whenTime: number): void {
    if (this.activePitchClasses.length === 0) {
      console.log('No active pitch classes!');
      return;
    }

    const pitchClass = this.activePitchClasses[
      Math.floor(Math.random() * this.activePitchClasses.length)
    ];
    const octave = OCTAVE_MIN + Math.floor(Math.random() * (OCTAVE_MAX - OCTAVE_MIN + 1));
    const midi = octave * 12 + pitchClass;
    const frequency = midiToFreq(midi);

    console.log('Triggering note:', { pitchClass, octave, midi, frequency, whenTime });
    this.triggerNote(frequency, whenTime);
    
    if (this.onNoteTriggered) {
      this.onNoteTriggered(pitchClass);
    }
  }

  private scheduleNextNote(currentTime: number): void {
    const deltaSeconds = Math.max(0.01, this.generateExponentialDelay());
    const target = currentTime + deltaSeconds;
    this.nextNoteTime = this.quantizeToSixteenth(target);
  }

  private scheduler(): void {
    if (!this.isPlaying || !Tone) {
      console.log('Scheduler stopped: isPlaying=', this.isPlaying);
      return;
    }

    const currentTime = Tone.now();
    const lookAhead = 0.15; // 150ms lookahead for smoother scheduling

    // Check for graph hop (chord change)
    if (currentTime >= this.nextGraphHopTime - lookAhead) {
      this.pcsGraph.advance();
      this.refreshPitchClasses();
      this.nextGraphHopTime += this.barSeconds * BARS_PER_CHANGE;
    }

    // Check for note events
    let notesTriggered = 0;
    while (this.nextNoteTime <= currentTime + lookAhead && notesTriggered < 5) {
      const noteTime = Math.max(this.nextNoteTime, currentTime + 0.01);
      this.triggerRandomNote(noteTime);
      this.scheduleNextNote(this.nextNoteTime);
      notesTriggered++;
    }

    // Schedule next check
    this.schedulerId = window.setTimeout(() => this.scheduler(), 25);
  }

  async start(): Promise<void> {
    if (this.isPlaying) return;

    try {
      // Dynamically import Tone.js only when needed (must be in user gesture)
      if (!Tone) {
        console.log('Loading Tone.js...');
        Tone = await import('tone');
        console.log('Tone.js loaded');
      }

      // Start audio context - this MUST complete before any audio node creation
      console.log('Starting audio context...');
      await Tone.start();
      console.log('Audio context started, state:', Tone.getContext().state);

      // Skip master gain - connect synths directly to destination
      // This avoids connect() issues with Tone.js dynamic imports
      console.log('Audio setup complete');

      this.refreshPitchClasses();
      console.log('Initial pitch classes:', this.activePitchClasses);

      // Set initial timing
      const startTime = Tone.now();
      this.nextNoteTime = startTime;
      this.nextGraphHopTime = startTime + this.barSeconds * BARS_PER_CHANGE;
      this.scheduleNextNote(startTime);

      this.isPlaying = true;
      this.updateMediaSessionState();
      if (this.onPlayStateChange) {
        this.onPlayStateChange(true);
      }
      
      console.log('Starting scheduler, first note at:', this.nextNoteTime);
      this.scheduler();
    } catch (error) {
      console.error('Failed to start audio engine:', error);
      this.stop();
      throw error;
    }
  }

  stop(): void {
    this.isPlaying = false;

    if (this.schedulerId !== null) {
      clearTimeout(this.schedulerId);
      this.schedulerId = null;
    }

    // Release all voices using safe disposal
    for (const voice of this.voices) {
      this.safeDispose(voice.synth);
      voice.synth = null;
      this.safeDispose(voice.vibrato);
      voice.vibrato = null;
      this.safeDispose(voice.tremolo);
      voice.tremolo = null;
    }
    this.voices = [];

    // Cleanup audio nodes
    this.safeDispose(this.reverb);
    this.reverb = null;
    this.safeDispose(this.masterGain);
    this.masterGain = null;

    this.updateMediaSessionState();
    if (this.onPlayStateChange) {
      this.onPlayStateChange(false);
    }
  }

  toggle(): Promise<void> {
    if (this.isPlaying) {
      this.stop();
      return Promise.resolve();
    } else {
      return this.start();
    }
  }

  getIsPlaying(): boolean {
    return this.isPlaying;
  }
}
